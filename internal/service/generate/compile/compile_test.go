package compile

import (
	"go/ast"
	"go/token"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/moorara/gelato/internal/log"
	"github.com/moorara/gelato/internal/service/generate/compile/node"
)

func TestNew(t *testing.T) {
	logger := log.New(log.None)
	clogger := &log.ColorfulLogger{
		Red:     logger,
		Green:   logger,
		Yellow:  logger,
		Blue:    logger,
		Magenta: logger,
		Cyan:    logger,
		White:   logger,
	}

	c := New(clogger)

	assert.NotNil(t, c)
	assert.NotNil(t, c.logger)
	assert.NotNil(t, c.builder)
	assert.NotNil(t, c.mocker)
}

func TestCompiler_Compile(t *testing.T) {
	logger := log.New(log.None)
	clogger := &log.ColorfulLogger{
		Red:     logger,
		Green:   logger,
		Yellow:  logger,
		Blue:    logger,
		Magenta: logger,
		Cyan:    logger,
		White:   logger,
	}

	inputFile := &ast.File{
		Name: &ast.Ident{
			Name: "lookup",
		},
		Decls: []ast.Decl{
			// Imports
			&ast.GenDecl{
				Tok: token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Value: "fmt",
						},
					},
				},
			},
			// Structs
			&ast.GenDecl{
				Tok: token.TYPE,
				Specs: []ast.Spec{
					&ast.TypeSpec{
						Name: &ast.Ident{Name: "Request"},
						Type: &ast.StructType{
							Fields: &ast.FieldList{
								List: []*ast.Field{
									{
										Names: []*ast.Ident{
											&ast.Ident{Name: "ID"},
										},
										Type: &ast.Ident{Name: "string"},
									},
								},
							},
						},
					},
				},
			},
			&ast.GenDecl{
				Tok: token.TYPE,
				Specs: []ast.Spec{
					&ast.TypeSpec{
						Name: &ast.Ident{Name: "Response"},
						Type: &ast.StructType{
							Fields: &ast.FieldList{
								List: []*ast.Field{
									{
										Names: []*ast.Ident{
											&ast.Ident{Name: "Name"},
										},
										Type: &ast.Ident{Name: "string"},
									},
								},
							},
						},
					},
				},
			},
			// Interfaces
			&ast.GenDecl{
				Tok: token.TYPE,
				Specs: []ast.Spec{
					&ast.TypeSpec{
						Name: &ast.Ident{Name: "Service"},
						Type: &ast.InterfaceType{
							Methods: &ast.FieldList{
								List: []*ast.Field{
									{
										Names: []*ast.Ident{
											&ast.Ident{Name: "Lookup"},
										},
										Type: &ast.FuncType{
											Params: &ast.FieldList{
												List: []*ast.Field{
													{
														Type: &ast.StarExpr{
															X: &ast.Ident{Name: "Request"},
														},
													},
												},
											},
											Results: &ast.FieldList{
												List: []*ast.Field{
													{
														Type: &ast.StarExpr{
															X: &ast.Ident{Name: "Response"},
														},
													},
													{
														Type: &ast.Ident{Name: "error"},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}

	expectedFile := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: 1,
					Text:  "// DO NOT EDIT",
				},
				{
					Slash: 16,
					Text:  "// Code generated by Gelato",
				},
			},
		},
		Package: 45,
		Name: &ast.Ident{
			NamePos: 53,
			Name:    "lookuptest",
		},
		Decls: []ast.Decl{
			// Imports
			&ast.GenDecl{
				TokPos: 65,
				Tok:    token.IMPORT,
				Lparen: 72,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							ValuePos: 75,
							Value:    `"github.com/octocat/app/example"`,
						},
					},
				},
				Rparen: 109,
			},
		},
	}

	tests := []struct {
		name         string
		builder      *MockBuilder
		mocker       *MockMocker
		pkgPath      string
		file         *ast.File
		expectedFile *ast.File
	}{
		{
			name: "OK",
			builder: &MockBuilder{
				CreateDeclsMocks: []BuilderCreateDeclsMock{
					{OutDecls: []ast.Decl{}},
					{OutDecls: []ast.Decl{}},
				},
			},
			mocker: &MockMocker{
				CreateDeclsMocks: []MockerCreateDeclsMock{
					{OutDecls: []ast.Decl{}},
				},
			},
			pkgPath:      "github.com/octocat/app/example",
			file:         inputFile,
			expectedFile: expectedFile,
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			c := &Compiler{
				logger:  clogger,
				factory: node.NewFactory(),
				builder: tc.builder,
				mocker:  tc.mocker,
			}

			file := c.Compile(tc.pkgPath, tc.file)

			assert.Equal(t, tc.expectedFile, file)
		})
	}
}
