package decorator

import (
	"fmt"
	"go/ast"
	"go/token"
	"path/filepath"

	"github.com/moorara/gelato/internal/service/compiler"
)

type pkgDecorator struct {
	interfaceName string
	structName    string
	imports       []ast.Spec
	decls         []ast.Decl
}

func (d *pkgDecorator) Package(info *compiler.PackageInfo, pkg *ast.Package) bool {
	return isDecoratablePkg(info.ImportPath)
}

func (d *pkgDecorator) FilePre(info *compiler.FileInfo, file *ast.File) bool {
	d.imports, d.decls = nil, nil
	return true
}

func (d *pkgDecorator) FilePost(info *compiler.FileInfo, file *ast.File) error {
	if len(d.imports) == 0 && len(d.decls) == 0 {
		return nil
	}

	// Imports
	importDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: d.imports,
	}

	// Import the original package for referencing
	importDecl.Specs = append(importDecl.Specs,
		&ast.ImportSpec{
			Name: &ast.Ident{
				Name: getOriginalPkgName(info.PackageName),
			},
			Path: &ast.BasicLit{
				Value: fmt.Sprintf("%q", info.ImportPath),
			},
		},
	)

	newFile := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{Slash: 1, Text: "// DO NOT EDIT"},
				{Slash: 16, Text: "// Code generated by Gelato"},
			},
		},
		Package: 45,
		Name: &ast.Ident{
			NamePos: 53,
			Name:    info.PackageName,
		},
		Decls: append([]ast.Decl{importDecl}, d.decls...),
	}

	filePath := filepath.Join(info.BaseDir, decoratedDir, info.RelativeDir, info.FileName)
	if err := compiler.WriteFile(filePath, info.FileSet, newFile); err != nil {
		return err
	}

	return nil
}

func (d *pkgDecorator) Import(info *compiler.FileInfo, spec *ast.ImportSpec) {
	d.imports = append(d.imports, spec)
}

func (d *pkgDecorator) Interface(info *compiler.TypeInfo, node *ast.InterfaceType) {
	if info.IsExported() {
		d.interfaceName = info.TypeName
	}
}

func (d *pkgDecorator) Struct(info *compiler.TypeInfo, node *ast.StructType) {
	if !info.IsExported() {
		decl := &ast.GenDecl{
			Tok: token.TYPE,
			Specs: []ast.Spec{
				&ast.TypeSpec{
					Name: &ast.Ident{Name: info.TypeName},
					Type: &ast.StructType{
						Fields: &ast.FieldList{
							List: []*ast.Field{
								// Implementation
								{
									Names: []*ast.Ident{
										{Name: "impl"},
									},
									Type: &ast.SelectorExpr{
										X: &ast.Ident{
											Name: getOriginalPkgName(info.PackageName),
										},
										Sel: &ast.Ident{
											// TODO: This is based on the assumption that the interface implementing the struct is defined before the struct
											Name: d.interfaceName,
										},
									},
								},
							},
						},
					},
				},
			},
		}

		d.structName = info.TypeName
		d.decls = append(d.decls, decl)
	}
}

func (d *pkgDecorator) FuncDecl(info *compiler.FuncInfo, funcType *ast.FuncType, body *ast.BlockStmt) {
	if info.IsExported() {
		if !info.IsMethod() { // The "New" function
			d.createNewFunction(info, funcType, body)
		} else { // A method of the unexported struct implementing the exported interface
			d.createDecoratedMethod(info, funcType, body)
		}
	}
}

// This assumes a new function returns only two values.
// The first value is type of the exported interface.
// The second value is type of error.
func (d *pkgDecorator) createNewFunction(info *compiler.FuncInfo, funcType *ast.FuncType, body *ast.BlockStmt) {
	args := []ast.Expr{}
	for _, param := range funcType.Params.List {
		for _, name := range param.Names {
			args = append(args, &ast.Ident{Name: name.Name})
		}
	}

	// TODO: reference interface from original package

	decl := &ast.FuncDecl{
		Name: &ast.Ident{Name: info.FuncName},
		Type: &ast.FuncType{
			Params:  funcType.Params,
			Results: funcType.Results,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.Ident{Name: "impl"},
						&ast.Ident{Name: "err"},
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   &ast.Ident{Name: getOriginalPkgName(info.PackageName)},
								Sel: &ast.Ident{Name: info.FuncName},
							},
							Args: args,
						},
					},
				},
				&ast.IfStmt{
					Cond: &ast.BinaryExpr{
						X:  &ast.Ident{Name: "err"},
						Op: token.NEQ,
						Y:  &ast.Ident{Name: "nil"},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									&ast.Ident{Name: "nil"},
									&ast.Ident{Name: "err"},
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: &ast.Ident{Name: d.structName},
								Elts: []ast.Expr{
									&ast.KeyValueExpr{
										Key:   &ast.Ident{Name: "impl"},
										Value: &ast.Ident{Name: "impl"},
									},
								},
							},
						},
						&ast.Ident{Name: "nil"},
					},
				},
			},
		},
	}

	d.decls = append(d.decls, decl)
}

func (d *pkgDecorator) createDecoratedMethod(info *compiler.FuncInfo, funcType *ast.FuncType, body *ast.BlockStmt) {
	args := []ast.Expr{}
	for _, param := range funcType.Params.List {
		for _, name := range param.Names {
			args = append(args, &ast.Ident{Name: name.Name})
		}
	}

	callExpr := &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X: &ast.SelectorExpr{
				X:   &ast.Ident{Name: info.RecvName},
				Sel: &ast.Ident{Name: "impl"},
			},
			Sel: &ast.Ident{Name: info.FuncName},
		},
		Args: args,
	}

	var stmt ast.Stmt
	if len(funcType.Results.List) == 0 {
		stmt = &ast.ExprStmt{X: callExpr}
	} else {
		stmt = &ast.ReturnStmt{
			Results: []ast.Expr{callExpr},
		}
	}

	decl := &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						{Name: info.RecvName},
					},
					Type: &ast.StarExpr{
						X: &ast.Ident{Name: d.structName},
					},
				},
			},
		},
		Name: &ast.Ident{Name: info.FuncName},
		Type: &ast.FuncType{
			Params:  funcType.Params,
			Results: funcType.Results,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{stmt},
		},
	}

	d.decls = append(d.decls, decl)
}
